# 系统生命周期与配置管理 (System Lifecycle & Configuration)

本文档记录了关于系统启动、配置修改、以及在调整底层参数（如线程数）时所需的重启流程和用户体验设计。

## 1. 配置分类 (Configuration Classification)

为了平衡灵活性与性能，我们将系统配置分为两类：

### 1.1 热更新配置 (Hot-Reload Settings)
*   **定义:** 修改后立即生效，**不需要**重启后端服务。
*   **包含项:**
    *   AI 模型参数 (API Key, Model Name, Prompt)。
    *   Webhook 通知地址 (URL, 开关)。
    *   告警阈值规则。
*   **实现:** 前端发送 `POST /settings`，后端更新内存中的对象 (Mutex保护)，下一次请求即使用新配置。

### 1.2 冷启动配置 (Cold-Start Settings)
*   **定义:** 修改后**必须重启**后端进程才能生效。
*   **包含项:**
    *   **线程池参数:** 
        *   `io_threads` (IO 线程数)
        *   `interactive_threads` (交互线程池大小)
        *   `worker_threads` (工作线程池大小)
    *   **网络参数:** 监听端口 (Port)。
    *   **存储参数:** 数据库路径 (DB Path)。
*   **实现:** 配置存入 SQLite，但当前运行的进程无法动态调整（例如 C++ `ThreadPool` 难以在运行时动态扩容且不丢失任务）。必须触发“保存并重启”流程。

---

## 2. 系统运行状态 (Lifecycle States)

系统在运行时存在三种主要状态：

1.  **运行中 (Running):**
    *   正常处理 `/logs` 提交。
    *   正常响应 `/dashboard` 查询。
    *   **UI 限制:** 冷启动配置项（线程数）呈 **灰色/不可用** 状态，或点击时弹出提示“请先停止服务”。

2.  **待机/暂停 (Standby):**
    *   用户点击“停止”按钮后进入此状态。
    *   后端行为: 依然运行，但对 `POST /logs` 返回 `503 Service Unavailable`（或在内存中直接丢弃并记录）。
    *   **UI 行为:** 冷启动配置项 **解锁**，允许用户修改。

3.  **重启中 (Restarting):**
    *   当用户在“待机”状态下修改了冷启动配置并点击“启动/应用”时触发。
    *   后端行为: 保存配置 -> 优雅退出 (Exit) -> 由外部脚本 (Launcher) 重新拉起。
    *   **UI 行为:** 显示 **全屏重启动画**（Loading Spinner），并轮询 `/health` 接口等待服务恢复。

---

## 3. 线程数调整交互流程 (UX Flow)

为了防止用户误操作导致服务意外中断，采用以下交互流程：

1.  **初始状态:** 系统正在运行，用户看到“工作线程数: 4”。输入框被禁用。
2.  **暂停服务:** 用户点击顶部的 **"停止 (Stop)"** 按钮。
    *   状态变为 "Standby"。
    *   输入框变为可用。
3.  **修改参数:** 用户将“工作线程数”从 4 改为 8。
4.  **应用变更:** 用户点击 **"启动 (Start)"** 或 **"保存并重启"**。
5.  **前端判断:** 
    *   前端检测到 `worker_threads` 发生了变化（对比原始值）。
    *   前端弹出确认框：“修改线程配置需要重启服务，是否继续？”
6.  **执行重启:**
    *   用户确认。
    *   前端发送 `POST /settings` (更新数据库)。
    *   前端发送 `POST /restart` (触发重启信号)。
    *   前端立即进入 **"服务重启中..."** 遮罩层，开始每 0.5秒 轮询一次后端健康检查接口。
7.  **服务恢复:**
    *   后端进程重启完成。
    *   前端轮询收到 `200 OK`。
    *   遮罩层消失，显示“运行中”，当前生效线程数为 8。

---

## 4. 技术实现细节

### 4.1 启动器 (Launcher) 的角色
由于 C++ 程序很难“自己重启自己”（exec 替换进程较为复杂且容易出错），建议利用 Python 启动脚本 (`run_tool.py`) 来管理生命周期。

*   **逻辑:**
    *   Python 脚本启动 C++ Server 子进程。
    *   Python 脚本监控子进程状态。
    *   **协议:** 如果 C++ Server 以特定退出码（例如 `exit_code=100`）退出，Python 脚本则认为这是一个“重启请求”，会立即重新启动 Server 进程。
    *   如果是正常退出 (`exit_code=0`)，则 Python 脚本也随之结束。

### 4.2 线程模型参数
根据 `docs/FUTURE_ARCHITECTURE.md`，我们需要存储三个核心参数：
*   **IO Threads:** 负责网络 IO (MiniMuduo EventLoop)。通常设为 1。
*   **Interactive Pool:** 负责前端 API。通常设为 1。
*   **Worker Pool:** 负责 AI 和日志处理。建议设为 CPU 核数 ~ 2倍核数。

这些参数将在 `server/src/main.cpp` 启动时从 `SqliteConfigRepository` 读取。
